// Java Interface in Depth - Part 1

    Interface is something which helps 2 system to interact with each other, without one system has to know the details of other.
    OR, it helps to achieve "abstraction".


    In simple terms, User - system 2, Car - system 2, interface - brake
        so, user does not know how the brake is applied internally by the car when user brakes.

    How to define the interface:
        Interface declaration consists of:
            - Modifiers
            - "interface" keyword
            - Interface Name
            - Comma separated list of parent interfaces.
            - Body

        Only Public and Default modifiers are allowed. (Protected and Private are not allowed.)

        eg:
            public interface Bird {
                public void fly();
            }

               // default
            interface Bird {
                public void fly();
            }

        Comma separated list of parent interfaces (it can extend from Class) eg:

            public interface NonFlyingBirds extends Bird, LivingThings {
                public void canRun();
            }


        Bird - interface1, LivingThings - interface2
            NonFlyingBirds - interface3 - extends the above two.

    Why we need an interface ?

    1. Abstraction:

        Using interface, we can achieve full abstraction, means we can define WHAT class must do, but not HOW it will do.

        public interface Bird {
            public void fly(); // signature / no implementation
        }

        //

        public class Eagle implements Bird {
            @Override
            public void fly() {
            // the logic is handled here.
            }
        }

    2. Polymorphism:

        Interface can be used as a data type:

        - we cannot create the object of an interface, but it can hold the reference of all the classes which implements it.
        And at runtime, it decide which method need to be invoked.


        eg:

            public interface Bird {
                public void fly();
            }

            public class Eagle implements Bird {
                @Override
                public void fly() {
                    SOPln("Eagle Fly Implementation");
                }
            }

            public class Hen implements Bird {
                @Override
                public void fly() {
                    SOPln("Hen Fly Implementation");
                }
            }

            public class Main() {
                public static void main(String args[]) {
                    Bird birdObject1 = new Eagle(); // used as a datatype
                    Bird birdObject2 = new Hen(); // created hen object and stored into birdObject2 of type Bird

                    birdObject1.fly();
                    birdObject2.fly();
                }
            }

            3. Multiple inheritance:

                In Java, multiple inheritance is possible only through interface only.

                Diamond problem:

                    public class WaterAnimal {
                        public boolean canBreathe() {

                        }
                    }

                    public class LandAnimal {
                        public boolean canBreathe() {

                        }
                    }

                    public class Crocodile extends LandAnimal, WaterAnimal {
                        // not allowed in Java.
                    }

                    public Class Main {
                        public static void main(String args[]) {
                            Crocodile obj = new Crocodile();
                            obj.canBreathe(); // now this don't know which one to call.
                        }
                    }


                BUT in case of interface:


                    public class WaterAnimal {
                        public boolean canBreathe();
                    }

                    public class LandAnimal {
                        public boolean canBreathe();
                    }

                    public class Crocodile implements LandAnimal, WaterAnimal {
                        @Override
                        public boolean canBreathe() {
                            // impl is provided here.
                        }
                    }

                    public class Main {
                        public class void main(String args[]) {
                            Crocodile obj = new Crocodile();
                            obj.canBreathe(); // now no issues with the compiler.
                        }
                    }

                    // Methods in an interface:

                    - All methods are implicit public only.
                    - Method cannot be declared as final.


                    public interface Bird {
                        void fly();
                        public void hasBrake(); // both are same
                    }

               FIELDS in interface:

               - Fields are public, static and final implicitly (CONSTANTS)
               - You cannot make field private or protected.

               public interface Bird {
                    int MAX_HEIGHT_IN_FEET = 2000;
               }

               is equal to:

               public interface Bird {
                    public static final int MAX_HEIGHT_IN_FEET = 2000;
               }

             Interface Implementation:

             - Overriding method can not have more restrict access specifiers.
             - Concrete class must override all the methods declared in the interface.
             - Abstract classes are not forced to override all the methods.
             - A class can implement from multiple interfaces.


             eg:

                public interface Bird {
                    public void fly(); // by default method is public
                }

                public class Eagle implements Bird {
                    @Override
                    public void fly() {
                    }
                }

                // now this one is not right
                public class Eagle implements Bird {
                    @Override
                    protected void fly() {
                    // cant restrict access specifier
                    }
                }


                //

                public interface Bird {
                    public void canFly();
                    public void noOfLegs();
                }

                public abstract class Eagle implements Bird {
                    @Override
                    public void canFly() {
                        // Implementation
                    }

                    public abstract void beakLength() {
                    }
                }

                public class WhiteEagle extends Eagle {

                    @Override
                    public void noOfLegs() {
                        // implement interface method.
                    }

                    @Override
                    public void beakLength() {
                        // Implementing abstract class methods.
                    }

                }

             // Nested Interface. (good to know)

                - Nested Interface means Interface declared within another Interface.
                - Nested Interface declared within a class.

               Generally it is used to group logical related interfaces. and nested interface.

               Rules -
                - A nested interface declared within an interface must be public.
                - A nested interface declared within a class can have any access modifier.
                - When you implement outer interface, inner interface implementation is not required and vice versa.


               public interface Bird {
               // outer interface
                public void canFly(); // abstract method
                public interface NonFlyingBird {
                    public void canRun();
                }
               }

               // lets say we want to access the outer interface.
               public class Eagle implements Bird {
                    @Override
                    public void canFly() {
                        // just provide the implementation of the outer class
                    }
               }

               // to access the inner nested interface
               public class Eagle implements Bird.NonFlyingBird {
                    @Override
                    public void canRun() {
                        // only provide the inner interface methods impl.
                    }
               }

               public class Main {
                psvm(String args[]) {
                    Bird.NonFlyingBird obj = new Eagle();
                    obj.canRun();
                }
               }

               public class Eagle implements Bird, Bird.NonFLyingBird {
                    @Override
                    public void canRun() {

                    }

                    @Override
                     public void canFly() {

                    }
               }

               // interface within a class example

               public class Bird {

                // whenever we are doing nested interface within a class, then we can mention the access specifier as private or protected
                    protected interface NonFlyingBird {

                        public void canRun();
                    }
               }


               public class Eagle implements Bird.NonFlyingBird {
                    @Override
                    public void canRun() {

                    }
               }

            Interface vs Abstract class:

            Abstract class:

            1. Keyword used here is abstract
            2. Child classes need to use keyword extends
            3. It can have both abstract and non-abstract methods
            4. It can extend from another class and multiple interfaces.
            5. Variables can be static, non static, final, non final, etc
            6. Variables and Methods can be private, public, protected, default
            7. Multiple Inheritance is not supported.
            8. It can provide the implementation of the interface.
            9. It can have constructor.
            10. To declare the method abstract, we have to use abstract keyword and it can be protected, public, default


            Interface:
            1. Keyword used here is interface.
            2. Child classes need to use keyword implements
            3. It can have only abstract methods. (from Java8 it can have default, static, private method too, where we can provide implementation)
            4. It can only extend from other interfaces.
            5. Variable are by default CONSTANTS.
            6. Variables and Methods are by default public (In Java9, private method is supported.)
            7. Multiple Inheritance is supported with this in Java
            8. It cannot provide implementation of any other interface or abstract class.
            9. It cannot have constructor.
            10. No need for any keyword to make method abstract and be default its public.











